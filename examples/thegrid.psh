
// The Grid - a port of the UVM example
// https://github.com/maximecb/uvm/blob/master/ncc/examples/thegrid.c

let FRAME_WIDTH = 800;
let FRAME_HEIGHT = 600;
let COLOR_PURPLE = 0xFF_D6_00_FF;

// --- 3D Math ---

class Vec3 {
    init(self, x, y, z) {
        self.x = x;
        self.y = y;
        self.z = z;
    }
}

// Identity matrix
fun mat4_identity() {
    return [
        [1.0, 0.0, 0.0, 0.0],
        [0.0, 1.0, 0.0, 0.0],
        [0.0, 0.0, 1.0, 0.0],
        [0.0, 0.0, 0.0, 1.0],
    ];
}

// Multiply a Vec3 by a 4x4 matrix
fun mat4_transform(m, i) {
    let o = Vec3(0, 0, 0);

    o.x = i.x * m[0][0] + i.y * m[1][0] + i.z * m[2][0] + m[3][0];
    o.y = i.x * m[0][1] + i.y * m[1][1] + i.z * m[2][1] + m[3][1];
    o.z = i.x * m[0][2] + i.y * m[1][2] + i.z * m[2][2] + m[3][2];
    let w = i.x * m[0][3] + i.y * m[1][3] + i.z * m[2][3] + m[3][3];

    if (w.floor() != 0) {
        o.x = o.x/w;
        o.y = o.y/w;
    }

    return o;
}

fun perspective(fov_rad, aspect, near, far) {
    let m = mat4_identity();
    let f = 1.0 / (fov_rad / 2.0).tan();

    m[0][0] = f / aspect;
    m[1][1] = f;
    m[2][2] = (far + near) / (near - far);
    m[2][3] = -1.0;
    m[3][2] = (2.0 * far * near) / (near - far);
    m[3][3] = 0.0;

    return m;
}

// --- Graphics ---

fun remap(v, a0, a1, b0, b1) {
    return b0 + (b1 - b0) * ((v - a0) / (a1 - a0));
}

// Optimized line drawing function
fun draw_line(buffer, x0, y0, x1, y1, color) {
    let x0_i = x0.floor();
    let y0_i = y0.floor();
    let x1_i = x1.floor();
    let y1_i = y1.floor();

    // If the line is horizontal, use the optimized fill function
    if (y0_i == y1_i) {
        if (y0_i < 0 || y0_i >= FRAME_HEIGHT) { return; }
        let var start_x = (x0_i).min(x1_i);
        let end_x = (x0_i).max(x1_i);
        let var width = end_x - start_x;
        if (start_x < 0) {
            width = width + start_x;
            start_x = 0;
        }
        if (start_x + width > FRAME_WIDTH) {
            width = FRAME_WIDTH - start_x;
        }
        if (width <= 0) { return; }
        buffer.fill_u32(y0_i * FRAME_WIDTH + start_x, width, color);
        return;
    }

    let dx = (x1_i - x0_i).abs();
    let dy = (y1_i - y0_i).abs();
    let sx = (x0_i < x1_i) ? 1 : -1;
    let sy = (y0_i < y1_i) ? 1 : -1;
    let var err = dx - dy;

    let var x = x0_i;
    let var y = y0_i;

    loop {
        if (x >= 0 && x < FRAME_WIDTH && y >= 0 && y < FRAME_HEIGHT) {
            buffer.write_u32(y * FRAME_WIDTH + x, color);
        }

        if (x == x1_i && y == y1_i) {
            break;
        }

        let e2 = 2 * err;
        if (e2 > -dy) {
            err = err - dy;
            x = x + sx;
        }
        if (e2 < dx) {
            err = err + dx;
            y = y + sy;
        }
    }
}

fun draw_line3d(buffer, persp, v0, v1, color) {
    let v_tmp0 = mat4_transform(persp, v0);
    let x0 = remap(v_tmp0.x, -1.0, 1.0, FRAME_WIDTH.to_f(), 0.0);
    let y0 = remap(v_tmp0.y, -1.0, 1.0, FRAME_HEIGHT.to_f(), 0.0);

    let v_tmp1 = mat4_transform(persp, v1);
    let x1 = remap(v_tmp1.x, -1.0, 1.0, FRAME_WIDTH.to_f(), 0.0);
    let y1 = remap(v_tmp1.y, -1.0, 1.0, FRAME_HEIGHT.to_f(), 0.0);

    draw_line(buffer, x0, y0, x1, y1, color);
}

// --- Color ---

fun rgb32(r, g, b) {
    return 0xFF_00_00_00 | (r << 16) | (g << 8) | b;
}

fun hue2rgb(p, q, t) {
    let var t_ = t;
    if (t_ < 0.0) { t_ = t_ + 1.0; }
    if (t_ > 1.0) { t_ = t_ - 1.0; }
    if (t_ < 1.0 / 6.0) { return p + (q - p) * 6.0 * t_; }
    if (t_ < 1.0 / 2.0) { return q; }
    if (t_ < 2.0 / 3.0) { return p + (q - p) * (2.0 / 3.0 - t_) * 6.0; }
    return p;
}

fun hsl_to_rgb(h, s, l) {
    if (s == 0.0) {
        let c = (255.0 * l).floor();
        return rgb32(c, c, c);
    } else {
        let q = (l < 0.5) ? (l * (1.0 + s)) : (l + s - l * s);
        let p = 2.0 * l - q;
        let r = hue2rgb(p, q, h + 1.0/3.0);
        let g = hue2rgb(p, q, h);
        let b = hue2rgb(p, q, h - 1.0/3.0);
        return rgb32((r * 255.0).floor(), (g * 255.0).floor(), (b * 255.0).floor());
    }
}

// --- Main ---

fun main() {
    let window = $window_create(FRAME_WIDTH, FRAME_HEIGHT, "The Grid", 0);
    let frame_buffer = ByteArray.with_size(FRAME_WIDTH * FRAME_HEIGHT * 4);

    let persp = perspective(
        (40.0 * 3.14159 / 180.0), // 40 degrees FOV in radians
        FRAME_WIDTH.to_f() / FRAME_HEIGHT.to_f(),
        0.1,
        100.0
    );

    let var line_pos = 1.0;
    let var anim_time = 0.0;

    loop {
        let start_time = $time_current_ms();

        // Clear the frame buffer
        frame_buffer.zero_fill();

        line_pos = line_pos - 0.03;
        if (line_pos < 0.0) {
            line_pos = line_pos + 1.0;
        }

        let h = 0.70 + 0.05 * (anim_time * 0.30).sin();
        let s = 0.95 + 0.05 * (anim_time * 0.20).sin();
        let l_max = 0.92 + 0.08 * (anim_time * 0.22).sin();

        // Draw sky/horizon
        for (let var i = 0; i < 335; ++i) {
            let color = hsl_to_rgb(h, s, (i / 335.0) * l_max);
            frame_buffer.fill_u32(i * FRAME_WIDTH, FRAME_WIDTH, color);
        }

        // Horizontal lines
        for (let var i = 0; i < 25; ++i) {
            let v0 = Vec3(-20.0, -1.0, -(0.1 + i + line_pos));
            let v1 = Vec3(20.0, -1.0, -(0.1 + i + line_pos));
            draw_line3d(frame_buffer, persp, v0, v1, COLOR_PURPLE);
        }

        // Vertical lines
        for (let var i = 0; i < 20; ++i) {
            let v0 = Vec3(-10.0 + i, -1.0, -20.0);
            let v1 = Vec3(-10.0 + i, -1.0, -0.1);
            draw_line3d(frame_buffer, persp, v0, v1, COLOR_PURPLE);
        }

        let end_time = $time_current_ms();
        let dt = end_time - start_time;
        $print(dt);
        $println("ms");

        $window_draw_frame(window, frame_buffer);

        anim_time = anim_time + (1.0 / 60.0);

        // Event handling
        let msg = $actor_poll();
        if (msg != nil && msg instanceof UIEvent && (msg.kind == 'CLOSE_WINDOW' || (msg.kind == 'KEY_DOWN' && msg.key == 'ESCAPE'))) {
            break;
        }

        $actor_sleep(16);
    }
}

main();
