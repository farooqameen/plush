let FRAME_WIDTH = 1024;
let FRAME_HEIGHT = 600;

// --- Lighting ---
let LIGHT_DIRECTION = Vec3(0.5, 1.0, -0.5).normalize(); // Example: from top-right-front
let AMBIENT_LIGHT = 0.3; // A small constant light

// --- 3D Math and Classes ---

let PI = 3.1415926535;

// Converts an angle from degrees to radians
fun deg2rad(deg) {
    return deg * PI / 180.0;
}

class Image {
    init(self, width, height) {
        self.width = width;
        self.height = height;
        self.bytes = ByteArray.with_size(4 * width * height);
    }

    fill(self, color) {
        self.bytes.fill_u32(0, self.width * self.height, color);
    }
}

class Vec3 {
    init(self, x, y, z) {
        self.x = x;
        self.y = y;
        self.z = z;
    }

    clone(self) {
        return Vec3(self.x, self.y, self.z);
    }

    add(self, other) {
        return Vec3(self.x + other.x, self.y + other.y, self.z + other.z);
    }

    sub(self, other) {
        return Vec3(self.x - other.x, self.y - other.y, self.z - other.z);
    }

    mul(self, scalar) {
        return Vec3(self.x * scalar, self.y * scalar, self.z * scalar);
    }

    dot(self, other) {
        return self.x * other.x + self.y * other.y + self.z * other.z;
    }

    cross(self, other) {
        return Vec3(
            self.y * other.z - self.z * other.y,
            self.z * other.x - self.x * other.z,
            self.x * other.y - self.y * other.x
        );
    }

    length_squared(self) {
        return self.dot(self);
    }

    normalize(self) {
        let len = self.length_squared().sqrt();
        if (len == 0.0) {
            return Vec3(0.0, 0.0, 0.0);
        }
        return Vec3(self.x / len, self.y / len, self.z / len);
    }
}

// Initializes a 4x4 matrix with zeros
// Matrices are row-major
fun mat4_init(m) {
    for (let var i = 0; i < 4; ++i) {
        let row = Array.with_size(4, 0.0);
        m.push(row);
    }
}

// Transform a 3D point using a 4x4 transformation matrix
fun mat4_mul_vec(i, m) {
    let o = Vec3(0, 0, 0);
    o.x   = i.x * m[0][0] + i.y * m[0][1] + i.z * m[0][2] + m[0][3];
    o.y   = i.x * m[1][0] + i.y * m[1][1] + i.z * m[1][2] + m[1][3];
    o.z   = i.x * m[2][0] + i.y * m[2][1] + i.z * m[2][2] + m[2][3];
    let w = i.x * m[3][0] + i.y * m[3][1] + i.z * m[3][2] + m[3][3];

    if (w != 0.0) {
        o.x = o.x / w;
        o.y = o.y / w;
        o.z = o.z / w;
    }

    return o;
}

// Multiplies two 4x4 matrices
fun mat4_mul(a, b) {
    let result = [];
    mat4_init(result);
    for (let var i = 0; i < 4; ++i) {
        for (let var j = 0; j < 4; ++j) {
            for (let var k = 0; k < 4; ++k) {
                result[i][j] = result[i][j] + a[k][j] * b[i][k];
            }
        }
    }
    return result;
}

// Matrix for a rotation around the X axis
fun mat4_rotx(theta)
{
    let result = [];
    mat4_init(result);

    let cost = theta.cos();
    let sint = theta.sin();

    // First row
    result[0][0] = 1.0;

    // Second
    result[1][1] = cost;
    result[1][2] = -sint;

    // Third row
    result[2][1] = sint;
    result[2][2] = cost;

    return result;
}

// Matrix for a rotation around the Y axis
fun mat4_roty(theta)
{
    let result = [];
    mat4_init(result);

    let cost = theta.cos();
    let sint = theta.sin();

    // First row
    result[0][0] = cost;
    result[0][2] = sint;

    // Second row
    result[1][1] = 1.0;

    // Third row
    result[2][0] = -sint;
    result[2][2] = cost;

    return result;
}

// --- Color Conversion (HSL to RGB) ---

fun hue2rgb(p, q, t)
{
    let var t_ = t;
    if (t_ < 0.0)
        t_ = t_ + 1.0;
    if (t_ > 1.0)
        t_ = t_ - 1.0;
    if (t_ < 1.0 / 6.0)
        return p + (q - p) * 6.0 * t_;
    if (t_ < 1.0 / 2.0)
        return q;
    if (t_ < 2.0 / 3.0)
        return p + (q - p) * (2.0 / 3.0 - t_) * 6.0;
    return p;
}

fun hsl_to_rgb(h, s, l)
{
    if (s < 0.01)
    {
        // simple gray conversion
        let c = (l * 255.0).floor();
        return 0xFF000000 | (c << 16) | (c << 8) | c;
    }

    // convert hue from [0, 360( to range [0,6)
    let var h_ = h / 60.0;
    if (h_ >= 6.0)
        h_ = h_ - 6.0;

    // break "h" down into integer and fractional parts.
    let i = h_.floor();
    let f = h_ - i;

    // Compute the permuted RGB values
    let vi = (l * 255.0).floor();
    let p = ((l * (1.0 - s)) * 255.0).floor();
    let q = ((l * (1.0 - (s * f))) * 255.0).floor();
    let t = ((l * (1.0 - (s * (1.0 - f)))) * 255.0).floor();

    // map l, p, q, and t into red, green, and blue values
    if (i == 0)
        return 0xFF000000 | (vi << 16) | (t << 8) | p;
    if (i == 1)
        return 0xFF000000 | (q << 16) | (vi << 8) | p;
    if (i == 2)
        return 0xFF000000 | (p << 16) | (vi << 8) | t;
    if (i == 3)
        return 0xFF000000 | (p << 16) | (q << 8) | vi;
    if (i == 4)
        return 0xFF000000 | (t << 16) | (p << 8) | vi;

    return 0xFF000000 | (vi << 16) | (p << 8) | q;
}

// Generate a perspective projection matrix identical to that
// produced by the gluPerspective() function.
// This is used to project coordinates from eye space into clip space.
// We follow OpenGL conventions.
//
// aspect = screen_width / screen_height
// fovy is in radians
//
// +Y points up,
// +X points to the right,
// -Z points into the screen.
//
// Points are projected such that X/Y are in [-1, 1]
// Z values between [near, far] get projected into [-1, 1]
// Points behind the near plane should be discarded (clipped) ahead of time.
//
fun perspective(fovy_rad, aspect, near, far) {
    let m = [];
    mat4_init(m);

    let f = 1.0 / (fovy_rad / 2.0).tan();
    let nf = 1.0 / (near - far);

    m[0][0] = f / aspect;
    m[0][1] = 0.0;
    m[0][2] = 0.0;
    m[0][3] = 0.0;

    m[1][0] = 0.0;
    m[1][1] = f;
    m[1][2] = 0.0;
    m[1][3] = 0.0;

    m[2][0] = 0.0;
    m[2][1] = 0.0;
    m[2][2] = (far + near) * nf;
    m[2][3] = 2.0 * far * near * nf;

    m[3][0] = 0.0;
    m[3][1] = 0.0;
    m[3][2] = -1.0;
    m[3][3] = 0.0;

    return m;
}

// Creates a view matrix that looks at a target from a given position
fun lookat(eye, target, up) {
    let forward = target.sub(eye).normalize();
    let right = forward.cross(up).normalize();
    let new_up = right.cross(forward);

    let m = [];
    mat4_init(m);

    m[0][0] = right.x;
    m[0][1] = right.y;
    m[0][2] = right.z;
    m[0][3] = -right.dot(eye);

    m[1][0] = new_up.x;
    m[1][1] = new_up.y;
    m[1][2] = new_up.z;
    m[1][3] = -new_up.dot(eye);

    m[2][0] = -forward.x;
    m[2][1] = -forward.y;
    m[2][2] = -forward.z;
    m[2][3] = forward.dot(eye);

    m[3][0] = 0.0;
    m[3][1] = 0.0;
    m[3][2] = 0.0;
    m[3][3] = 1.0;

    return m;
}

// Represents a 3D camera
class Camera {
    // Initializes the camera
    init(self, pos, target, fov_x, near, far) {
        self.pos = pos;
        self.target = target;
        self.fov_x = fov_x;
        self.near = near;
        self.far = far;
    }

    // Calculates the view matrix for the camera
    view_matrix(self) {
        let up = Vec3(0.0, 1.0, 0.0);
        return lookat(self.pos, self.target, up);
    }

    // Calculates the projection matrix for the camera
    projection_matrix(self, aspect) {
        let fov_x_rad = deg2rad(self.fov_x);
        let fov_y_rad = 2 * ((fov_x_rad / 2.0).tan() / aspect).atan();
        return perspective(fov_y_rad, aspect, self.near, self.far);
    }
}

// --- Triangle Rasterization ---

// This function expects the coordinates to be floats such that
// x is in [0, FRAME_WIDTH] and +x points right
// y is in [0, FRAME_HEIGHT] and +y points down
fun rasterize_triangle(v0, v1, v2, color, image) {
    let var p0 = v0;
    let var p1 = v1;
    let var p2 = v2;
    if (p0.y > p1.y) { let tmp = p0; p0 = p1; p1 = tmp; }
    if (p0.y > p2.y) { let tmp = p0; p0 = p2; p2 = tmp; }
    if (p1.y > p2.y) { let tmp = p1; p1 = p2; p2 = tmp; }

    let y0 = p0.y.floor();
    let y1 = p1.y.floor();
    let y2 = p2.y.floor();

    if (y0 == y2) return;

    let x0 = p0.x;
    let x1 = p1.x;
    let x2 = p2.x;

    let var inv_slope1 = 0.0;
    if (p1.y > p0.y) inv_slope1 = (x1 - x0) / (p1.y - p0.y);

    let var inv_slope2 = 0.0;
    if (p2.y > p0.y) inv_slope2 = (x2 - x0) / (p2.y - p0.y);

    let start_scanline_y_top = y0.max(0);
    let end_scanline_y_top = y1.min(FRAME_HEIGHT);

    if (start_scanline_y_top < end_scanline_y_top) {
        let var cur_x1 = x0 + (start_scanline_y_top - y0) * inv_slope1;
        let var cur_x2 = x0 + (start_scanline_y_top - y0) * inv_slope2;

        for (let var scanline_y = start_scanline_y_top; scanline_y < end_scanline_y_top; ++scanline_y) {
            let start_x = cur_x1.min(cur_x2).floor().max(0);
            let end_x = cur_x1.max(cur_x2).floor().min(FRAME_WIDTH);
            if (start_x < end_x) {
                image.bytes.fill_u32(scanline_y * FRAME_WIDTH + start_x, end_x - start_x, color);
            }
            cur_x1 = cur_x1 + inv_slope1;
            cur_x2 = cur_x2 + inv_slope2;
        }
    }

    let var inv_slope3 = 0.0;
    if (p2.y > p1.y) inv_slope3 = (x2 - x1) / (p2.y - p1.y);

    let start_scanline_y_bot = y1.max(0);
    let end_scanline_y_bot = y2.min(FRAME_HEIGHT);

    if (start_scanline_y_bot < end_scanline_y_bot) {
        let var cur_x1 = x1 + (start_scanline_y_bot - y1) * inv_slope3;
        let var cur_x2 = x0 + (start_scanline_y_bot - y0) * inv_slope2;

        for (let var scanline_y = start_scanline_y_bot; scanline_y < end_scanline_y_bot; ++scanline_y) {
            let start_x = cur_x1.min(cur_x2).floor().max(0);
            let end_x = cur_x1.max(cur_x2).floor().min(FRAME_WIDTH);
            if (start_x < end_x) {
                image.bytes.fill_u32(scanline_y * FRAME_WIDTH + start_x, end_x - start_x, color);
            }
            cur_x1 = cur_x1 + inv_slope3;
            cur_x2 = cur_x2 + inv_slope2;
        }
    }
}

// --- Procedural Data Generation ---

let var lcg_seed = 1;
fun rand_init(seed) { lcg_seed = seed & 0x7FFFFFFF; }
fun rand_float(min_val, max_val) {
    lcg_seed = (lcg_seed * 1103515245 + 12345) & 0x7FFFFFFF;
    let val = lcg_seed.to_f() / 0x7FFFFFFF.to_f();
    return min_val + val * (max_val - min_val);
}

class RenderData {
    init(self) {
        self.vertices = [];
        self.indices = [];
        self.colors = [];
        self.normals = []; // New: Store normals for each triangle
    }

    transform(self, mat) {
        for (let var i = 0; i < self.vertices.len; ++i) {
            let v = mat4_mul_vec(self.vertices[i], mat);

            // We need to invert Y to match screen coordinates
            v.x = (v.x + 1) * 0.5 * FRAME_WIDTH;
            v.y = (1 - v.y) * 0.5 * FRAME_HEIGHT;

            self.vertices[i] = v;
        }
    }

    // Sort the triangles by depth so that they can be rendered back to front
    sort_triangles(self) {
        let num_triangles = self.indices.len _/ 3;
        if (num_triangles == 0) {
            return;
        }

        // Create an array to store the original order of triangles
        let triangle_order = Array.with_size(num_triangles, 0);
        for (let var i = 0; i < num_triangles; ++i) {
            triangle_order[i] = i;
        }

        // Calculate the depth of each triangle
        let depths = Array.with_size(num_triangles, 0.0);
        for (let var i = 0; i < num_triangles; ++i) {
            let v0 = self.vertices[self.indices[i*3]];
            let v1 = self.vertices[self.indices[i*3+1]];
            let v2 = self.vertices[self.indices[i*3+2]];
            depths[i] = v0.z.max(v1.z).max(v2.z);
        }

        // Partition function for quicksort, operating on triangle_order
        fun partition(low, high) {
            let pivot_depth = depths[triangle_order[high]];
            let var i = low - 1;

            for (let var j = low; j < high; ++j) {
                // Sort back to front (larger Z is further away)
                if (depths[triangle_order[j]] > pivot_depth) {
                    i = i + 1;

                    // Swap triangle_order elements
                    let temp_order = triangle_order[i];
                    triangle_order[i] = triangle_order[j];
                    triangle_order[j] = temp_order;
                }
            }

            // Swap the pivot element in triangle_order
            let i1 = i + 1;
            let temp_order = triangle_order[i1];
            triangle_order[i1] = triangle_order[high];
            triangle_order[high] = temp_order;

            return i1;
        }

        // Quicksort implementation, operating on triangle_order
        fun quicksort(low, high) {
            if (low < high) {
                let pi = partition(low, high);
                quicksort(low, pi - 1);
                quicksort(pi + 1, high);
            }
        }

        quicksort(0, num_triangles - 1);

        // Rearrange self.indices, self.colors, and self.normals based on the sorted triangle_order
        let new_indices = Array.with_size(num_triangles * 3, 0);
        let new_colors = Array.with_size(num_triangles, 0);
        let new_normals = Array.with_size(num_triangles, 0); // New: for normals

        for (let var k = 0; k < num_triangles; ++k) {
            let original_triangle_idx = triangle_order[k];
            new_colors[k] = self.colors[original_triangle_idx];
            new_indices[k*3] = self.indices[original_triangle_idx*3];
            new_indices[k*3+1] = self.indices[original_triangle_idx*3+1];
            new_indices[k*3+2] = self.indices[original_triangle_idx*3+2];
            new_normals[k] = self.normals[original_triangle_idx]; // New: copy normal
        }
        self.indices = new_indices;
        self.colors = new_colors;
        self.normals = new_normals; // New: assign new normals array
    }
}

fun generate_cube(data, center_x, y, center_z, size_x, size_y, size_z, color) {
    let base_idx = data.vertices.len;

    let half_x = size_x / 2.0;
    let half_z = size_z / 2.0;

    // Vertices of the cube
    data.vertices.push(Vec3(center_x - half_x, y,        center_z - half_z)); // 0
    data.vertices.push(Vec3(center_x + half_x, y,        center_z - half_z)); // 1
    data.vertices.push(Vec3(center_x + half_x, y,        center_z + half_z)); // 2
    data.vertices.push(Vec3(center_x - half_x, y,        center_z + half_z)); // 3
    data.vertices.push(Vec3(center_x - half_x, y + size_y, center_z - half_z)); // 4
    data.vertices.push(Vec3(center_x + half_x, y + size_y, center_z - half_z)); // 5
    data.vertices.push(Vec3(center_x + half_x, y + size_y, center_z + half_z)); // 6
    data.vertices.push(Vec3(center_x - half_x, y + size_y, center_z + half_z)); // 7

    // Top face
    data.indices.push(base_idx + 7); data.indices.push(base_idx + 6); data.indices.push(base_idx + 5);
    data.indices.push(base_idx + 7); data.indices.push(base_idx + 5); data.indices.push(base_idx + 4);
    // Front face
    data.indices.push(base_idx + 3); data.indices.push(base_idx + 2); data.indices.push(base_idx + 6);
    data.indices.push(base_idx + 3); data.indices.push(base_idx + 6); data.indices.push(base_idx + 7);
    // Back face
    data.indices.push(base_idx + 4); data.indices.push(base_idx + 5); data.indices.push(base_idx + 1);
    data.indices.push(base_idx + 4); data.indices.push(base_idx + 1); data.indices.push(base_idx + 0);
    // Left face
    data.indices.push(base_idx + 0); data.indices.push(base_idx + 3); data.indices.push(base_idx + 7);
    data.indices.push(base_idx + 0); data.indices.push(base_idx + 7); data.indices.push(base_idx + 4);
    // Right face
    data.indices.push(base_idx + 6); data.indices.push(base_idx + 2); data.indices.push(base_idx + 1);
    data.indices.push(base_idx + 6); data.indices.push(base_idx + 1); data.indices.push(base_idx + 5);

    // Add colors and normals for each triangle
    // Top face
    data.normals.push(Vec3(0.0, 1.0, 0.0)); // Normal for (7,6,5)
    data.normals.push(Vec3(0.0, 1.0, 0.0)); // Normal for (7,5,4)
    // Front face
    data.normals.push(Vec3(0.0, 0.0, 1.0)); // Normal for (3,2,6)
    data.normals.push(Vec3(0.0, 0.0, 1.0)); // Normal for (3,6,7)
    // Back face
    data.normals.push(Vec3(0.0, 0.0, -1.0)); // Normal for (4,5,1)
    data.normals.push(Vec3(0.0, 0.0, -1.0)); // Normal for (4,1,0)
    // Left face
    data.normals.push(Vec3(-1.0, 0.0, 0.0)); // Normal for (0,3,7)
    data.normals.push(Vec3(-1.0, 0.0, 0.0)); // Normal for (0,7,4)
    // Right face
    data.normals.push(Vec3(1.0, 0.0, 0.0)); // Normal for (6,2,1)
    data.normals.push(Vec3(1.0, 0.0, 0.0)); // Normal for (6,1,5)

    for (let var i = 0; i < 12; ++i) {
        data.colors.push(color);
    }
}

fun generate_ground_plane(data, min_coord, max_coord, color) {
    let base_idx = data.vertices.len;

    let y = -0.01;

    // Vertices of the plane
    data.vertices.push(Vec3(min_coord, y, min_coord)); // 0
    data.vertices.push(Vec3(max_coord, y, min_coord)); // 1
    data.vertices.push(Vec3(max_coord, y, max_coord)); // 2
    data.vertices.push(Vec3(min_coord, y, max_coord)); // 3

    // Indices for the 2 triangles of the plane (quad)
    // With normals pointing up (+Y)
    data.indices.push(base_idx + 0);
    data.indices.push(base_idx + 3);
    data.indices.push(base_idx + 2);

    data.indices.push(base_idx + 0);
    data.indices.push(base_idx + 2);
    data.indices.push(base_idx + 1);

    // Add colors and normals for each triangle
    data.colors.push(color);
    data.colors.push(color);
    data.normals.push(Vec3(0.0, 1.0, 0.0)); // Normal for first triangle
    data.normals.push(Vec3(0.0, 1.0, 0.0)); // Normal for second triangle
}

fun generate_city(data, grid_size)
{
    let cell_size = 100.0;
    let building_padding = 22.0;
    let max_height = 350.0;
    let building_base_size = cell_size - building_padding * 2.0;

    for (let var iz = 0; iz < grid_size; ++iz) {
        for (let var ix = 0; ix < grid_size; ++ix) {
            let center_x = ix * cell_size + cell_size / 2.0;
            let center_z = iz * cell_size + cell_size / 2.0;

            let height = rand_float(50.0, max_height);
            let var color = 0;

            if (rand_float(0.0, 1.0) < 0.3) {
                // Pale blue building, like glass
                let pale_factor = rand_float(0.85, 0.95);
                let r_val = (pale_factor * 255).floor();
                let g_val = (pale_factor * 255).floor();
                let b_val = 255;
                color = 0xFF000000 | (r_val << 16) | (g_val << 8) | b_val;
            } else {
                // Gray building
                let gray = rand_float(0.3, 0.8);
                let color_val = (gray * 255).floor();
                color = 0xFF000000 | (color_val << 16) | (color_val << 8) | color_val;
            }

            generate_cube(
                data,
                center_x,
                0.0,
                center_z,
                building_base_size,
                height,
                building_base_size,
                color
            );
        }
    }
}

// --- Main ---

let window = $window_create(FRAME_WIDTH, FRAME_HEIGHT, "Procedural City Example", 0);
let image = Image(FRAME_WIDTH, FRAME_HEIGHT);

// Generate city
let city_data = RenderData();
let grid_size = 10;
generate_city(city_data, grid_size);

// Generate ground plane
let city_size = grid_size * 100.0;
let ground_min = -city_size * 0.15;
let ground_max = city_size * 1.15;
let ground_color = 0xFF383838; // Dark gray
generate_ground_plane(city_data, ground_min, ground_max, ground_color);

// Keep a copy of the original vertices
let orig_city_vertices = [];
for (let var i = 0; i < city_data.vertices.len; ++i) {
    orig_city_vertices.push(city_data.vertices[i].clone());
}

// Camera setup
let aspect = FRAME_WIDTH.to_f() / FRAME_HEIGHT.to_f();
let city_center = Vec3(city_size / 2.0, 150.0, city_size / 2.0);
let camera = Camera(
    Vec3(500.0, 100.0, 1600.0),
    city_center,
    90.0,   // fov
    0.1,
    10_000.0
);

let mat_proj = camera.projection_matrix(aspect);
let var anim_time = 0.0;

// Main animation loop
loop {
    // --- Event Handling ---
    let msg = $actor_poll();
    if (msg != nil && msg instanceof UIEvent && (msg.kind == 'CLOSE_WINDOW' || (msg.kind == 'KEY_DOWN' && msg.key == 'ESCAPE'))) {
        break;
    }

    // --- Animation Update ---
    anim_time = anim_time + 0.01;

    // --- Camera Update ---
    let radius = 1200.0;
    let cam_x = city_center.x + radius * anim_time.cos();
    let cam_z = city_center.z + radius * anim_time.sin();
    camera.pos = Vec3(cam_x, 600.0, cam_z);

    // --- Camera Matrix Calculation ---
    let mat_view = camera.view_matrix();
    let mat_vp = mat4_mul(mat_view, mat_proj);

    // --- Rendering ---
    // Draw sky gradient (sunset)
    for (let var y = 0; y < FRAME_HEIGHT; ++y) {
        let t = y.to_f() / FRAME_HEIGHT.to_f(); // Normalized position from bottom to top

        // Interpolate HSL values for sunset
        // Hue: from orange (e.g., 30) to deep blue (e.g., 240)
        // Saturation: from high (e.g., 0.9) to medium (e.g., 0.6)
        // Lightness: from medium (e.g., 0.5) to low (e.g., 0.2)

        let h_start = 220.0;
        let h_end = 240.0;
        let s_start = 0.6;
        let s_end = 0.95;
        let l_start = 0.99;
        let l_end = 0.8;

        // Quadratic interpolation to make changes faster at the bottom (horizon)
        let gradient_t = t * t;

        let h = h_start + (h_end - h_start) * gradient_t;
        let s = s_start + (s_end - s_start) * gradient_t;
        let l = l_start + (l_end - l_start) * gradient_t;

        let color = hsl_to_rgb(h, s, l);
        image.bytes.fill_u32(y * FRAME_WIDTH, FRAME_WIDTH, color);
    }

    // --- Render City ---
    let transform_start = $time_current_ms();
    city_data.vertices = [];
    for (let var i = 0; i < orig_city_vertices.len; ++i) {
        city_data.vertices.push(orig_city_vertices[i].clone());
    }
    city_data.transform(mat_vp);
    let transform_time = $time_current_ms() - transform_start;

    let sort_start = $time_current_ms();
    city_data.sort_triangles();
    let sort_time = $time_current_ms() - sort_start;

    let raster_start = $time_current_ms();
    for (let var i = 0; i < city_data.indices.len; i = i + 3) {
        let v0 = city_data.vertices[city_data.indices[i]];
        let v1 = city_data.vertices[city_data.indices[i+1]];
        let v2 = city_data.vertices[city_data.indices[i+2]];

        // Backface culling: check winding order in screen space.
        // This calculates the signed area of the 2D triangle.
        // If the area is negative, it's front-facing (clockwise winding).
        if ((v1.x - v0.x) * (v2.y - v0.y) - (v2.x - v0.x) * (v1.y - v0.y) < 0) {
            let triangle_normal = city_data.normals[i _/ 3]; // Get the normal for this triangle
            let base_color = city_data.colors[i _/ 3];

            // Calculate diffuse component (clamped to 0)
            let diffuse_intensity = (0.0).max(triangle_normal.dot(LIGHT_DIRECTION));

            // Apply lighting
            let var final_intensity = AMBIENT_LIGHT + diffuse_intensity;
            // Clamp final_intensity to 1.0 to prevent over-brightening
            final_intensity = final_intensity.min(1.0);

            // Extract color components and apply intensity
            let r = ((base_color >> 16) & 0xFF).to_f() * final_intensity;
            let g = ((base_color >> 8) & 0xFF).to_f() * final_intensity;
            let b = (base_color & 0xFF).to_f() * final_intensity;

            let shaded_color = 0xFF000000 | (r.floor() << 16) | (g.floor() << 8) | b.floor();

            rasterize_triangle(v0, v1, v2, shaded_color, image);
        }
    }
    let raster_time = $time_current_ms() - raster_start;

    $println(
        "triangles: " + city_data.colors.len.to_s() +
        ", transform: " + transform_time.to_s() +
        "ms, sort: " + sort_time.to_s() +
        "ms, rasterize: " + raster_time.to_s() + "ms"
    );

    $window_draw_frame(window, image.bytes);

    // --- Frame Limiting ---
    $actor_sleep(16);
}
