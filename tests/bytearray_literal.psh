let ba = #[\aASCII character sequence];
assert(ba[0] == 65);
assert(ba.len == 24);

let ba_esc = #[\a\t];
assert(ba_esc.len == 1);

let ba_comment = #[\afoo /* comment */];
assert(ba_comment.len == 4);

let ba_newline = #[
    \afoo
    \abar
];
assert(ba_newline.len == 6);

let ba2 = #[
    \athis is a multiline
    \aASCII character
    \asequence!
    \aThere can also be escape sequences
    \alike \t and \n, or \\ inside ASCII sequences
];
assert(ba2.len == 118);

let ba_hex = #[\x
    FF AA
    BB CC
    DD EE
];
assert(ba_hex.len == 6);
assert(ba_hex[0] == 0xFF);
assert(ba_hex[5] == 0xEE);

let ba_bin = #[\b
    00110011
    00000000
];
assert(ba_bin.len == 2);
assert(ba_bin[0] == 0b00110011);
assert(ba_bin[1] == 0b00000000);

// You can intermix ASCII, hex and binary sequences
// The control sequences \a, \x and \b allow you to switch modes
let ba_mix = #[
    \b
    00110011
    00000000

    // You can even put comments inside of
    // bytearray literals to explain what is being encoded
    \x
    FF AA BB CC
    DD EE BB AA

    /*
    Multiline comments
    also work normally
    */
    \aASCII data

    \x
    FF AA
    BB CC // Comment inside hex sequence
    DD EE
    BB AA

    \x
    CAFEBABE

    \aMore text data// Comment after text
    \aYet more text // Another comment
];
//$println(ba_mix.len);
assert(ba_mix.len == 60);
